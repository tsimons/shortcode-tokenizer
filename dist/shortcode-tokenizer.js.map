{"version":3,"sources":["webpack:///shortcode-tokenizer.js","webpack:///webpack/bootstrap 832e6efa9b7fdcd80394","webpack:///./src/shortcode-tokenizer.js"],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","_toConsumableArray","arr","Array","isArray","arr2","length","from","_classCallCheck","instance","Constructor","TypeError","getTokenType","str","CLOSE","SELF_CLOSING","OPEN","castValue","value","test","Number","toLowerCase","replace","Token","_typeof","Symbol","iterator","obj","constructor","_createClass","defineProperties","target","props","descriptor","writable","key","protoProps","staticProps","RX_KEY","RX_PARAMS","RX_OPEN","RX_SELFCLOSING","rxParams","RegExp","substring","rxEnclosure","rxOpen","rxClose","rxSelfclosing","type","body","pos","arguments","undefined","strict","this","children","params","isClosed","init","match","matchBody","SyntaxError","initName","initParams","paramStr","reduce","paramToken","trim","equal","indexOf","result","typeOfValue","value_","computedParams","buildParams","rx","token","ShortcodeTokenizer","input","options","skipWhiteSpace","assign","buf","originalBuf","Error","tokens","allTokens","_next","push","apply","stack","ast","parent","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","next","done","canClose","pop","err","return","build","childs","map","child","toString","join","index","console","warn","set","TEXT","ERROR"],"mappings":"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","file":"shortcode-tokenizer.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/*!******************************************!*\\\n  !*** multi ./src/shortcode-tokenizer.js ***!\n  \\******************************************/\n/*! dynamic exports provided */\n/*! all exports used */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(/*! /Users/thomassimons/Projects/shortcode-tokenizer/src/shortcode-tokenizer.js */1);\n\n\n/***/ }),\n/* 1 */\n/*!************************************!*\\\n  !*** ./src/shortcode-tokenizer.js ***!\n  \\************************************/\n/*! exports provided: Token, default */\n/*! all exports used */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Token\", function() { return Token; });\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/** @module ShortcodeTokenizer */\n\n/* tokens */\nvar TEXT = 'TEXT';\nvar ERROR = 'ERROR';\nvar OPEN = 'OPEN';\nvar CLOSE = 'CLOSE';\nvar SELF_CLOSING = 'SELF_CLOSING';\n\n/* eslint-disable */\n\n/* matches code name */\nvar RX_KEY = '[a-zA-Z][a-zA-Z0-9_-]*';\n\n/* matches paramters */\nvar RX_PARAM = RX_KEY + '=\\\\d+\\\\.\\\\d+' + // floats\n'|' + RX_KEY + '=\\\\d+' + // ints\n'|' + RX_KEY + '=(true|false|yes|no)' + // bools\n'|' + RX_KEY + '=\"[^\\\\]\"]*(<.*\".*)?\"' + // double-qouted strings\n'|' + RX_KEY + '=\\'[^\\\\]\\']*(<.*\\'.*)?\\'' + // single-qouted strings\n'|' + RX_KEY; // flags\nvar RX_PARAMS = '(?:(?:' + RX_PARAM + ')(?:(?!\\\\s+/?\\\\])\\\\s|))+';\n\n/* matches all code token types, used for quickly\n   finding potentia code tokens */\nvar RX_ENCLOSURE = '\\\\[\\\\/?[a-zA-Z][^\\\\]]+\\\\]';\n/* matches opening code tokens [row] */\nvar RX_OPEN = '\\\\[(' + RX_KEY + ')(\\\\s' + RX_PARAMS + ')?\\\\]';\n/* matches self-closing code tokens [row/] */\nvar RX_SELFCLOSING = '\\\\[(' + RX_KEY + ')(\\\\s' + RX_PARAMS + ')?\\\\s?\\\\/\\\\]';\n/* matches close code tokens [/row] */\nvar RX_CLOSE = '\\\\[\\\\/(' + RX_KEY + ')\\\\]';\n\n/* case-insensitive regular expressions */\nvar rxParams = new RegExp(RX_PARAMS.substring(0, RX_PARAMS.length - 1), 'ig');\nvar rxEnclosure = new RegExp(RX_ENCLOSURE, 'i');\nvar rxOpen = new RegExp(RX_OPEN, 'i');\nvar rxClose = new RegExp(RX_CLOSE, 'i');\nvar rxSelfclosing = new RegExp(RX_SELFCLOSING, 'i');\n\n/* eslint-enable */\n\n/**\n * Get token type based on token-string.\n *\n * Note: assuming that this is not a TEXT token\n *\n * @param {string} str\n * @returns {string} token type\n */\nfunction getTokenType(str) {\n  if (str[1] === '/') {\n    return CLOSE;\n  }\n  if (str[str.length - 2] === '/') {\n    return SELF_CLOSING;\n  }\n  return OPEN;\n}\n\n/**\n * Casts input string to native types.\n *\n * @param {string} value\n * @returns {*} mixed value\n */\nfunction castValue(value) {\n  if (/^\\d+$/.test(value)) return Number(value);\n  if (/^\\d+.\\d+$/.test(value)) return Number(value);\n  if (/^(true|false|yes|no)$/i.test(value)) {\n    value = value.toLowerCase();\n    return value === 'true' || value === 'yes';\n  }\n  return value.replace(/(^['\"]|['\"]$)/g, '');\n}\n\n/**\n * Token class is used both as a token during tokenization/lexing\n * and as a node in the resulting AST.\n */\nvar Token = function () {\n  function Token(type, body) {\n    var pos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var strict = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n    _classCallCheck(this, Token);\n\n    this.name = null;\n    this.type = type;\n    this.body = body;\n    this.pos = pos;\n    this.strict = strict;\n    this.children = [];\n    this.params = {};\n    this.isClosed = type === SELF_CLOSING;\n    this.init();\n  }\n\n  /**\n   * @access private\n   */\n\n\n  _createClass(Token, [{\n    key: 'init',\n    value: function init() {\n      if (this.type !== TEXT && this.type !== ERROR) {\n        var match = this.matchBody();\n        if (match === null) {\n          if (this.strict) {\n            throw new SyntaxError('Invalid ' + this.type + ' token: ' + this.body);\n          }\n        } else {\n          this.initName(match);\n          if (match[2]) {\n            this.initParams(match[2]);\n          }\n        }\n      }\n    }\n\n    /**\n     * @access private\n     */\n\n  }, {\n    key: 'initName',\n    value: function initName(match) {\n      this.name = match[1];\n    }\n\n    /**\n     * @access private\n     */\n\n  }, {\n    key: 'initParams',\n    value: function initParams(paramStr) {\n      var match = paramStr.match(rxParams);\n      this.params = match.reduce(function (params, paramToken) {\n        paramToken = paramToken.trim();\n        var equal = paramToken.indexOf('=');\n        if (!~equal) {\n          params[paramToken] = true;\n        } else {\n          params[paramToken.substring(0, equal)] = castValue(paramToken.substring(equal + 1));\n        }\n        return params;\n      }, {});\n    }\n\n    /**\n     * @return {string}\n     */\n\n  }, {\n    key: 'buildParams',\n    value: function buildParams() {\n      var result = '';\n\n      for (var key in this.params) {\n        if (this.params.hasOwnProperty(key)) {\n          var value = this.params[key];\n          var typeOfValue = typeof value === 'undefined' ? 'undefined' : _typeof(value);\n          if (typeOfValue === 'string') {\n            result = result + ' ' + key + '=\"' + value + '\"';\n          } else if (typeOfValue === 'boolean') {\n            var value_ = value ? 'true' : 'false';\n            result = result + ' ' + key + '=' + value_;\n          } else {\n            result = result + ' ' + key + '=' + value;\n          }\n        }\n      }\n\n      return result;\n    }\n\n    /**\n     * Convert token to string.\n     *\n     * @param {object|string|null} [params=null]\n     * @return {string}\n     */\n\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      if (params instanceof Object) {\n        this.params = params;\n      }\n\n      var computedParams = typeof params === 'string' ? ' ' + params.trim() : this.buildParams();\n\n      switch (this.type) {\n        case TEXT:\n          return this.body;\n\n        case OPEN:\n          return '[' + this.name + computedParams + ']' + (this.children.length ? '{slot}' : '') + '[/' + this.name + ']';\n\n        case SELF_CLOSING:\n          return '[' + this.name + computedParams + '/]';\n\n        default:\n          return '';\n      }\n    }\n\n    /**\n     * @access private\n     */\n\n  }, {\n    key: 'matchBody',\n    value: function matchBody() {\n      var rx = void 0;\n      if (this.type === CLOSE) {\n        rx = rxClose;\n      } else if (this.type === OPEN) {\n        rx = rxOpen;\n      } else if (this.type === SELF_CLOSING) {\n        rx = rxSelfclosing;\n      } else {\n        throw new SyntaxError('Unknown token: ' + this.type);\n      }\n\n      var match = this.body.match(rx);\n      return match;\n    }\n\n    /**\n     * Determines if this token can close the param token.\n     *\n     * @access public\n     * @param {Token} token another token\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'canClose',\n    value: function canClose(token) {\n      return this.name === token.name;\n    }\n  }]);\n\n  return Token;\n}();\n\n/**\n * Creates a new tokenizer.\n *\n * Pass in input as first param or later using `input()`\n *\n * @param {string} [input=null] Optional input to tokenize\n * @param {Object} [options] options object\n * @param {boolean} [options.strict=true] strict mode\n * @param {boolean} [options.skipWhiteSpace=false] will ignore tokens containing only white space (basically all \\s)\n */\n\nvar ShortcodeTokenizer = function () {\n  function ShortcodeTokenizer() {\n    var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { strict: true, skipWhiteSpace: false };\n\n    _classCallCheck(this, ShortcodeTokenizer);\n\n    if (typeof options === 'boolean') {\n      options = { strict: options, skipWhiteSpace: false };\n    }\n    this.options = Object.assign({ strict: true, skipWhiteSpace: false }, options);\n    this.buf = null;\n    this.originalBuf = null;\n    this.pos = 0;\n    if (input) {\n      this.input(input);\n    }\n  }\n\n  /**\n   * @deprecated use options.strict\n   */\n  /* istanbul ignore next */\n\n\n  _createClass(ShortcodeTokenizer, [{\n    key: 'input',\n\n\n    /**\n     * Sets input buffer with a new input string.\n     *\n     * @param {string} input template string\n     * @throws {Error} Invalid input\n     * @returns {this} returns this for chaining\n     */\n    value: function input(_input) {\n      if (typeof _input !== 'string') {\n        throw new Error('Invalid input');\n      }\n\n      this.buf = this.originalBuf = _input;\n      this.pos = 0;\n      return this;\n    }\n\n    /**\n     * Resets input buffer and position to their origial values.\n     *\n     * @returns {this} returns this for chaining\n     */\n\n  }, {\n    key: 'reset',\n    value: function reset() {\n      this.buf = this.originalBuf;\n      this.pos = 0;\n      return this;\n    }\n\n    /**\n     * Creates a token generator.\n     *\n     * @throws {Error} Invalid input\n     * @returns {Token[]} An array of Token instances\n     */\n\n  }, {\n    key: 'tokens',\n    value: function tokens() {\n      var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      if (input) {\n        this.input(input);\n      }\n\n      if (typeof this.buf !== 'string' && this.options.strict) {\n        throw new Error('Invalid input');\n      }\n\n      var tokens = [];\n      var allTokens = [];\n      while ((tokens = this._next()) !== null) {\n        tokens = Array.isArray(tokens) ? tokens : [tokens];\n        allTokens.push.apply(allTokens, _toConsumableArray(tokens));\n      }\n      return allTokens;\n    }\n\n    /**\n     * Uses the tokens generator to build an AST from the tokens.\n     *\n     * @see tokens\n     * @returns {array} an array of AST roots\n     */\n\n  }, {\n    key: 'ast',\n    value: function ast() {\n      var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      var tokens = this.tokens(input);\n      var stack = [];\n      var ast = [];\n      var parent = null;\n      var token = void 0;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = tokens[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          token = _step.value;\n\n          if (token.type === TEXT) {\n            if (this.options.skipWhiteSpace && token.body.replace(/\\s+/g, '').length === 0) {\n              continue;\n            }\n            if (!parent) {\n              ast.push(token);\n            } else {\n              parent.children.push(token);\n            }\n          } else if (token.type === OPEN) {\n            if (!parent) {\n              parent = token;\n              ast.push(parent);\n            } else {\n              parent.children.push(token);\n              stack.push(parent);\n              parent = token;\n            }\n          } else if (token.type === CLOSE) {\n            if (!parent || !token.canClose(parent)) {\n              if (this.options.strict) {\n                throw new SyntaxError('Unmatched close token: ' + token.body);\n              } else {\n                var err = new Token(ERROR, token.body, 0, this.options.strict);\n                if (!parent) {\n                  ast.push(err);\n                } else {\n                  parent.children.push(err);\n                }\n              }\n            } else {\n              parent.isClosed = true;\n              parent = stack.pop();\n            }\n          } else if (token.type === SELF_CLOSING) {\n            if (!parent) {\n              ast.push(token);\n            } else {\n              parent.children.push(token);\n            }\n          } else {\n            /* istanbul ignore next */\n            if (this.options.strict) {\n              throw new SyntaxError('Unknown token: ' + token.type);\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (parent) {\n        if (this.options.strict) {\n          throw new SyntaxError('Unmatched open token: ' + parent.body);\n        } else {\n          ast.push(new Token(ERROR, token.body, 0, this.options.strict));\n        }\n      }\n      return ast;\n    }\n\n    /**\n     * Build template by given token.\n     *\n     * @param {Token} token\n     * @param {object|string|null} [params=null]\n      * @throws {Error} Unexpected token type.\n     * @returns {string}\n     */\n\n  }, {\n    key: 'buildTemplate',\n    value: function buildTemplate(token) {\n      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (!token) {\n        return '';\n      }\n\n      if (!(token instanceof Token)) {\n        throw new Error('Expected Token instance.');\n      }\n\n      var build = function build(value) {\n        var childs = value.children.map(function (child) {\n          return child.children.length ? build(child) : child.toString();\n        });\n\n        return value.toString(params).replace('{slot}', childs.join(''));\n      };\n\n      return build(token);\n    }\n\n    /**\n     * Internal function used to retrieve the next token from the current\n     * position in the input buffer.\n     *\n     * @private\n     * @returns {Token} returns the next Token from the input buffer\n     */\n\n  }, {\n    key: '_next',\n    value: function _next() {\n      if (!this.buf) {\n        return null;\n      }\n\n      var match = this.buf.match(rxEnclosure);\n\n      // all text\n      if (match === null) {\n        var token = new Token(TEXT, this.buf, this.pos, this.options.strict);\n        this.pos += this.buf.length;\n        this.buf = null;\n        return token;\n      }\n\n      var tokens = [];\n\n      // first part is text\n      if (match.index !== 0) {\n        tokens.push(new Token(TEXT, this.buf.substring(0, match.index), this.pos, this.options.strict));\n      }\n\n      // matching token\n      tokens.push(new Token(getTokenType(match[0]), match[0], this.pos + match.index, this.options.strict));\n\n      // shorten buffer\n      this.buf = this.buf.substring(match.index + match[0].length);\n      this.pos += match.index + match[0].length;\n      if (this.buf.length === 0) {\n        this.buf = null;\n      }\n      return tokens;\n    }\n  }, {\n    key: 'strict',\n    get: function get() {\n      console.warn('Deprecated: use options.strict instead');\n      return this.options.strict;\n    }\n\n    /**\n     * @deprecated use options.strict\n     */\n    /* istanbul ignore next */\n    ,\n    set: function set(value) {\n      console.warn('Deprecated: use options.strict = ' + value + ' instead');\n      this.options.strict = value;\n    }\n  }]);\n\n  return ShortcodeTokenizer;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (ShortcodeTokenizer);\n\n\nObject.assign(ShortcodeTokenizer, {\n  TEXT: TEXT,\n  ERROR: ERROR,\n  OPEN: OPEN,\n  CLOSE: CLOSE,\n  SELF_CLOSING: SELF_CLOSING,\n  rxParams: rxParams,\n  rxEnclosure: rxEnclosure,\n  rxOpen: rxOpen,\n  rxClose: rxClose,\n  rxSelfclosing: rxSelfclosing\n});\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// shortcode-tokenizer.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 832e6efa9b7fdcd80394","/** @module ShortcodeTokenizer */\n\n/* tokens */\nconst TEXT = 'TEXT'\nconst ERROR = 'ERROR'\nconst OPEN = 'OPEN'\nconst CLOSE = 'CLOSE'\nconst SELF_CLOSING = 'SELF_CLOSING'\n\n/* eslint-disable */\n\n/* matches code name */\nconst RX_KEY = '[a-zA-Z][a-zA-Z0-9_-]*'\n\n/* matches paramters */\nconst RX_PARAM =       RX_KEY + '=\\\\d+\\\\.\\\\d+' +         // floats\n                 '|' + RX_KEY + '=\\\\d+' +                // ints\n                 '|' + RX_KEY + '=(true|false|yes|no)' + // bools\n                 '|' + RX_KEY + '=\"[^\\\\]\"]*(<.*\".*)?\"' +          // double-qouted strings\n                 '|' + RX_KEY + '=\\'[^\\\\]\\']*(<.*\\'.*)?\\'' +       // single-qouted strings\n                 '|' + RX_KEY                            // flags\nconst RX_PARAMS = '(?:(?:' + RX_PARAM + ')(?:(?!\\\\s+/?\\\\])\\\\s|))+'\n\n/* matches all code token types, used for quickly\n   finding potentia code tokens */\nconst RX_ENCLOSURE   = '\\\\[\\\\/?[a-zA-Z][^\\\\]]+\\\\]'\n/* matches opening code tokens [row] */\nconst RX_OPEN        = '\\\\[(' + RX_KEY + ')(\\\\s' + RX_PARAMS + ')?\\\\]'\n/* matches self-closing code tokens [row/] */\nconst RX_SELFCLOSING = '\\\\[(' + RX_KEY + ')(\\\\s' + RX_PARAMS + ')?\\\\s?\\\\/\\\\]'\n/* matches close code tokens [/row] */\nconst RX_CLOSE       = '\\\\[\\\\/(' + RX_KEY + ')\\\\]'\n\n/* case-insensitive regular expressions */\nconst rxParams      = new RegExp(RX_PARAMS.substring(0, RX_PARAMS.length - 1), 'ig')\nconst rxEnclosure   = new RegExp(RX_ENCLOSURE, 'i')\nconst rxOpen        = new RegExp(RX_OPEN, 'i')\nconst rxClose       = new RegExp(RX_CLOSE, 'i')\nconst rxSelfclosing = new RegExp(RX_SELFCLOSING, 'i')\n\n/* eslint-enable */\n\n/**\n * Get token type based on token-string.\n *\n * Note: assuming that this is not a TEXT token\n *\n * @param {string} str\n * @returns {string} token type\n */\nfunction getTokenType(str) {\n  if (str[1] === '/') {\n    return CLOSE\n  }\n  if (str[str.length - 2] === '/') {\n    return SELF_CLOSING\n  }\n  return OPEN\n}\n\n/**\n * Casts input string to native types.\n *\n * @param {string} value\n * @returns {*} mixed value\n */\nfunction castValue(value) {\n  if (/^\\d+$/.test(value)) return Number(value)\n  if (/^\\d+.\\d+$/.test(value)) return Number(value)\n  if (/^(true|false|yes|no)$/i.test(value)) {\n    value = value.toLowerCase()\n    return value === 'true' || value === 'yes'\n  }\n  return value.replace(/(^['\"]|['\"]$)/g, '')\n}\n\n/**\n * Token class is used both as a token during tokenization/lexing\n * and as a node in the resulting AST.\n */\nexport class Token {\n  constructor(type, body, pos = 0, strict = true) {\n    this.name = null\n    this.type = type\n    this.body = body\n    this.pos = pos\n    this.strict = strict\n    this.children = []\n    this.params = {}\n    this.isClosed = type === SELF_CLOSING\n    this.init()\n  }\n\n  /**\n   * @access private\n   */\n  init() {\n    if (this.type !== TEXT && this.type !== ERROR) {\n      const match = this.matchBody()\n      if (match === null) {\n        if (this.strict) {\n          throw new SyntaxError('Invalid ' + this.type + ' token: ' + this.body)\n        }\n      } else {\n        this.initName(match)\n        if (match[2]) {\n          this.initParams(match[2])\n        }\n      }\n    }\n  }\n\n  /**\n   * @access private\n   */\n  initName(match) {\n    this.name = match[1]\n  }\n\n  /**\n   * @access private\n   */\n  initParams(paramStr) {\n    const match = paramStr.match(rxParams)\n    this.params = match.reduce((params, paramToken) => {\n      paramToken = paramToken.trim()\n      let equal = paramToken.indexOf('=')\n      if (!~equal) {\n        params[paramToken] = true\n      } else {\n        params[paramToken.substring(0, equal)] = castValue(paramToken.substring(equal + 1))\n      }\n      return params\n    }, {})\n  }\n\n  /**\n   * @return {string}\n   */\n  buildParams() {\n    let result = ''\n\n    for (const key in this.params) {\n      if (this.params.hasOwnProperty(key)) {\n        const value = this.params[key];\n        const typeOfValue = typeof value\n        if (typeOfValue === 'string') {\n          result = `${result} ${key}=\"${value}\"`\n        } else if (typeOfValue === 'boolean') {\n          const value_ = value ? 'true' : 'false'\n          result = `${result} ${key}=${value_}`\n        } else {\n          result = `${result} ${key}=${value}`\n        }\n      }\n    }\n\n    return result\n  }\n\n  /**\n   * Convert token to string.\n   *\n   * @param {object|string|null} [params=null]\n   * @return {string}\n   */\n  toString(params = null) {\n    if (params instanceof Object) {\n      this.params = params\n    }\n\n    const computedParams = typeof params === 'string'\n      ? ` ${params.trim()}`\n      : this.buildParams()\n\n    switch (this.type) {\n      case TEXT:\n        return this.body\n\n      case OPEN:\n        return `[${this.name}${computedParams}]${this.children.length ? '{slot}' : ''}[/${this.name}]`\n\n      case SELF_CLOSING:\n        return `[${this.name}${computedParams}/]`\n\n      default:\n        return ''\n    }\n  }\n\n  /**\n   * @access private\n   */\n  matchBody() {\n    let rx\n    if (this.type === CLOSE) {\n      rx = rxClose\n    } else if (this.type === OPEN) {\n      rx = rxOpen\n    } else if (this.type === SELF_CLOSING) {\n      rx = rxSelfclosing\n    } else {\n      throw new SyntaxError('Unknown token: ' + this.type)\n    }\n\n    let match = this.body.match(rx)\n    return match\n  }\n\n  /**\n   * Determines if this token can close the param token.\n   *\n   * @access public\n   * @param {Token} token another token\n   * @returns {boolean}\n   */\n  canClose(token) {\n    return this.name === token.name\n  }\n}\n\n/**\n * Creates a new tokenizer.\n *\n * Pass in input as first param or later using `input()`\n *\n * @param {string} [input=null] Optional input to tokenize\n * @param {Object} [options] options object\n * @param {boolean} [options.strict=true] strict mode\n * @param {boolean} [options.skipWhiteSpace=false] will ignore tokens containing only white space (basically all \\s)\n */\nexport default class ShortcodeTokenizer {\n\n  constructor(input = null, options = {strict: true, skipWhiteSpace: false}) {\n    if (typeof options === 'boolean') {\n      options = {strict: options, skipWhiteSpace: false}\n    }\n    this.options = Object.assign({strict: true, skipWhiteSpace: false}, options)\n    this.buf = null\n    this.originalBuf = null\n    this.pos = 0\n    if (input) {\n      this.input(input)\n    }\n  }\n\n  /**\n   * @deprecated use options.strict\n   */\n  /* istanbul ignore next */\n   get strict() {\n    console.warn(`Deprecated: use options.strict instead`)\n    return this.options.strict\n  }\n\n  /**\n   * @deprecated use options.strict\n   */\n  /* istanbul ignore next */\n  set strict(value) {\n    console.warn(`Deprecated: use options.strict = ${value} instead`)\n    this.options.strict = value\n  }\n\n  /**\n   * Sets input buffer with a new input string.\n   *\n   * @param {string} input template string\n   * @throws {Error} Invalid input\n   * @returns {this} returns this for chaining\n   */\n  input(input) {\n    if (typeof input !== 'string') {\n      throw new Error('Invalid input')\n    }\n\n    this.buf = this.originalBuf = input\n    this.pos = 0\n    return this\n  }\n\n  /**\n   * Resets input buffer and position to their origial values.\n   *\n   * @returns {this} returns this for chaining\n   */\n  reset() {\n    this.buf = this.originalBuf\n    this.pos = 0\n    return this\n  }\n\n  /**\n   * Creates a token generator.\n   *\n   * @throws {Error} Invalid input\n   * @returns {Token[]} An array of Token instances\n   */\n  tokens(input = null) {\n    if (input) {\n      this.input(input)\n    }\n\n    if (typeof this.buf !== 'string' && this.options.strict) {\n      throw new Error('Invalid input')\n    }\n\n    let tokens = []\n    let allTokens = []\n    while ((tokens = this._next()) !== null) {\n      tokens = Array.isArray(tokens) ? tokens : [tokens]\n      allTokens.push(...tokens)\n    }\n    return allTokens\n  }\n\n  /**\n   * Uses the tokens generator to build an AST from the tokens.\n   *\n   * @see tokens\n   * @returns {array} an array of AST roots\n   */\n  ast(input = null) {\n    let tokens = this.tokens(input)\n    let stack = []\n    let ast = []\n    let parent = null\n    let token\n    for (token of tokens) {\n      if (token.type === TEXT) {\n        if (this.options.skipWhiteSpace && token.body.replace(/\\s+/g, '').length === 0) {\n          continue\n        }\n        if (!parent) {\n          ast.push(token)\n        } else {\n          parent.children.push(token)\n        }\n      } else if (token.type === OPEN) {\n        if (!parent) {\n          parent = token\n          ast.push(parent)\n        } else {\n          parent.children.push(token)\n          stack.push(parent)\n          parent = token\n        }\n      } else if (token.type === CLOSE) {\n        if (!parent || !token.canClose(parent)) {\n          if (this.options.strict) {\n            throw new SyntaxError('Unmatched close token: ' + token.body)\n          } else {\n            let err = new Token(ERROR, token.body, 0, this.options.strict)\n            if (!parent) {\n              ast.push(err)\n            } else {\n              parent.children.push(err)\n            }\n          }\n        } else {\n          parent.isClosed = true\n          parent = stack.pop()\n        }\n      } else if (token.type === SELF_CLOSING) {\n        if (!parent) {\n          ast.push(token)\n        } else {\n          parent.children.push(token)\n        }\n      } else {\n        /* istanbul ignore next */\n        if (this.options.strict) {\n          throw new SyntaxError('Unknown token: ' + token.type)\n        }\n      }\n    }\n    if (parent) {\n      if (this.options.strict) {\n        throw new SyntaxError('Unmatched open token: ' + parent.body)\n      } else {\n        ast.push(new Token(ERROR, token.body, 0, this.options.strict))\n      }\n    }\n    return ast\n  }\n\n  /**\n   * Build template by given token.\n   *\n   * @param {Token} token\n   * @param {object|string|null} [params=null]\n\n   * @throws {Error} Unexpected token type.\n   * @returns {string}\n   */\n  buildTemplate(token, params = null) {\n    if (!token) {\n      return ''\n    }\n\n    if (!(token instanceof Token)) {\n      throw new Error('Expected Token instance.')\n    }\n\n    const build = (value) => {\n      const childs = value.children.map(\n        child => (child.children.length ? build(child) : child.toString())\n      )\n\n      return value.toString(params).replace('{slot}', childs.join(''))\n    }\n\n    return build(token)\n  }\n\n  /**\n   * Internal function used to retrieve the next token from the current\n   * position in the input buffer.\n   *\n   * @private\n   * @returns {Token} returns the next Token from the input buffer\n   */\n  _next() {\n    if (!this.buf) {\n      return null\n    }\n\n    let match = this.buf.match(rxEnclosure)\n\n    // all text\n    if (match === null) {\n      let token = new Token(TEXT, this.buf, this.pos, this.options.strict)\n      this.pos += this.buf.length\n      this.buf = null\n      return token\n    }\n\n    let tokens = []\n\n    // first part is text\n    if (match.index !== 0) {\n      tokens.push(new Token(\n        TEXT,\n        this.buf.substring(0, match.index),\n        this.pos,\n        this.options.strict\n      ))\n    }\n\n    // matching token\n    tokens.push(new Token(\n      getTokenType(match[0]),\n      match[0],\n      this.pos + match.index,\n      this.options.strict\n    ))\n\n    // shorten buffer\n    this.buf = this.buf.substring(match.index + match[0].length)\n    this.pos += match.index + match[0].length\n    if (this.buf.length === 0) {\n      this.buf = null\n    }\n    return tokens\n  }\n}\n\nObject.assign(ShortcodeTokenizer, {\n  TEXT,\n  ERROR,\n  OPEN,\n  CLOSE,\n  SELF_CLOSING,\n  rxParams,\n  rxEnclosure,\n  rxOpen,\n  rxClose,\n  rxSelfclosing\n})\n\n\n\n// WEBPACK FOOTER //\n// ./src/shortcode-tokenizer.js"],"sourceRoot":""}